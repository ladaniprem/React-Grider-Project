// Variable Declarations with Type Annotations
const color: string = 'red';
const isRed: boolean = color === 'red';
const age: number = 20;

// Arrays with Type Annotations
const colors: string[] = [
    'red', 'green', 'blue'
    // Only strings allowed in this array
];

const areColorRed: boolean[] = [
    true, false, false
];

const ages: number[] = [
    20, 30, 40
];

// Function with Parameter and Return Type Annotations
function add(a: number, b: number): number {
    return a + b;
}

const sum = add(1, 5);

// Function to Print Array of Colors
function printColors(colors: string[]): void {
    console.log(colors);
}

printColors(['yellow', 'Rose Pink', 'Orange']);

// Function to Print Age
function printAge(age: number): void {
    console.log(age);
}
printAge(24);

// Type Inference Example
const hours = 10; // inferred as number
const ocean = 'pacific'; // inferred as string

function getName(): string {
    return 'Ladani prem';
}

// Interface Example
interface Car {
    year: number;
    model: string;
    make: string;
}

// Function using Interface as Parameter Type
function formatCar(car: Car): string {
    return `Year: ${car.year}, Model: ${car.model}, Make: ${car.make}`;
}

formatCar({
    year: 2012,
    make: 'Hyundai',
    model: 'Verna'
});

// Using Interface to Annotate Props in React Component
import React from 'react';

interface TaskShowProps {
    title: string;
    completed: boolean;
}

function TaskShow({ title, completed }: TaskShowProps) {
    return (
        <div>
            {title} - {completed ? 'Done' : 'Need to complete'}
        </div>
    );
}

// Example usage of TaskShow component
<TaskShow title="abc" completed={true} />;

// Theory:
// - Type annotations help catch errors at compile time.
// - Interfaces define the shape of objects and props in React.
// - Type inference lets TypeScript automatically determine variable types.
// - Always annotate function parameters and return types for clarity.


 - This code demonstrates the concept of TypeScript type inference and its limitations,
 - particularly when working with interfaces and object literals. It defines a `Car` interface
 - and shows how TypeScript enforces strict property checks on object literals assigned to typed variables.
  
 //  Key Points:
  - TypeScript's type inference can catch errors when extra or missing properties are present in object literals.
  - When an object literal contains properties not defined in the interface (e.g., `make`), TypeScript will raise an error.
  - The code also explores function types within interfaces, showing how to define methods (`setYear`, `setModel`, `getDescription`)
    as part of the `Car` interface.
  - Attempting to assign an object literal with methods to a variable of type `Car` will result in errors if the implementation
    does not match the interface exactly.
  - The example highlights the importance of matching interface definitions precisely and demonstrates how TypeScript's
    structural typing system enforces these contracts at compile time.
  
  //  Theory:
  - TypeScript uses structural typing, meaning that the shape of the object (its properties and methods) must match the interface.
  - Type inference helps catch errors early, but developers must ensure that all required properties and methods are present,
    and no extra properties are included unless explicitly allowed.
  - Defining function types in interfaces allows for more robust and predictable object structures, enabling better tooling and error checking.
 

// Example: Showing the downside of type inference with object literals and interfaces

interface Car {
    model: string;
    year: number;
}

// This will cause a TypeScript error because 'make' is not defined in the Car interface
const mustang: Car = {
    model: 'Mustang',
    year: 2015,
    make: '' // Error: Object literal may only specify known properties, and 'make' does not exist in type 'Car'
};

// This will also cause an error for the same reason
const camaro: Car = {
    model: 'camaro',
    year: 2010,
    make: '' // Error: Object literal may only specify known properties, and 'make' does not exist in type 'Car'
};

// The correct way is to only include properties defined in the interface
const civic: Car = {
    model: 'Civic',
    year: 2020
};

function printCar(car: Car) {
    console.log(car);
}

printCar(civic);

//Downside of the Type Inference

interface Car {
    model: string;
    year: number;
}

function printCar(car:Car){
    console.log(car);
}

const mustang : Car = {
model: 'Mustang',
year: 2015,
make: ''
};

const camaro : Car = {
model: 'camaro',
year: 2010,
make: ''
};

printCar(mustang);
printCar(camaro);

//Function Types  

interface Car {
    model: string;
    year: number;
    setYear : (Year:number) => void 
    setModel: (Model : string) => void
    getDescription: () => string;
}


const mustang : Car = {
model: 'Mustang',
year: 2015,
make: '',
setYear (nextYear : number)  // error was Object literal may only specify known properties, and 'setYear' does not exist in type 'Car' 
{
    this.year = nextYear;
};

setModel(nextModel : string){
    this.model = nextModel;
},

getDescription() {
    return `Year:${this.year} , model:${this.model}`
},
 
};

mustang.setModel()




 - ColorPickerProps interface defines the props for the ColorPicker component.
 - colors: An array of color strings to display as selectable options.
 - handleColorSelect: Callback function invoked when a color is selected.
 


 - ColorPicker is a React functional component that renders a list of color buttons.
 - When a button is clicked, it calls the handleColorSelect function with the selected color.
  
 - Example usage:
  <ColorPicker
    colors={['red', 'green', 'blue']}
    handleColorSelect={(color) => console.log(color)}
  />
 
  ButtonProps interface defines the props for the Button component.
  - label: The text to display on the button.
  - onClick: Callback function invoked when the button is clicked.
 
 - Button is a simple React functional component that renders a button with a label.
 - When clicked, it calls the onClick handler.
 
 - IconButtonProps extends ButtonProps and adds:
 - icon: A string representing the icon to display alongside the label.
 
 - IconButton is a React functional component that renders a button with an icon and label.
 - It calls the onClick handler when clicked.
 
 - Type Unions:
 - Demonstrates how to use union types in TypeScript to allow a function parameter to accept multiple types.
 - Example: string | number | string[] | image
  
 - This allows the logOutput function to accept a string, number, array of strings, or an image object.
 - Passing a type not included in the union (e.g., boolean) will result in a TypeScript error.

 -  Type Narrowing with Type Guards:
 -  Shows how to use type guards (typeof, Array.isArray) to narrow down the type of a union parameter at runtime.
 -  This enables safe access to properties and methods specific to each type.
  
  - Example:
  - typeof value === 'string' allows string-specific operations.
  - Array.isArray(value) checks for arrays.
  - typeof value === 'object' && !Array.isArray(value) checks for objects (e.g., image).
 
 - Type Predicates:
 - Demonstrates how to distinguish between different object types in a union (e.g., Image | User).
 - Type predicates can be used to create custom type guards for more complex scenarios.

 
// function types 
import React from 'react';

interface ColorPickerProps {
  colors: string[];
  handleColorSelect: (color: string) => void;
}

function ColorPicker({ colors, handleColorSelect }: ColorPickerProps) {
  const renderedColors = colors.map(color => {
    return (
      <button key={color} onClick={() => handleColorSelect(color)}>
        {color}
      </button>
    );
  });

  return (
    <>
      <div>{renderedColors}</div>
      <ColorPicker
        colors={['red', 'green', 'blue']}
        handleColorSelect={(color: string) => console.log(color)}
      />
      </>
  );
}


 import React from 'react';

 interface ButtonProps {
     label  : string;
     onClick : () => void;
 }


 function Button({ label, onClick }: ButtonProps) {
   return <button onClick={onClick}>{label}</button>;
 }
 interface IconButtonProps extends ButtonProps{
     icon : string;
 }
 function IconButton({ label, onClick, icon} : IconButtonProps){
       return <button onClick = {() => onClick()}>  {icon}{label} </button>
 }

 // type Unions 
// interface image {
//     src: string;
// }
// function logOutput(value: string | number | string[] | image )
// {
   
// }

// logOutput('hi bro');
// logOutput(1234);
// logOutput(['hi','bro']);
// logOutput({ src : 'image.jpg'})

// logOutput(true); Argument of type 'boolean' is not assignable to parameter of type 'string | number | image | string[]'.


// Type Narrowing with Type Guards 

// interface image {
//     src: string;
// }
// function logOutput(value: string | number | string[] | image )
// {
//     // if value is a string...
//    if (typeof value === 'string') { 
//        value.toUpperCase();
//    }
// }

// logOutput('hi bro');
// logOutput(1234);
// logOutput(['hi','bro']);
// logOutput({ src : 'image.jpg'})


// Tricky cases with Type Guards

interface image {
    src: string;
}
function logOutput(value: string | number | string[] | image )
{
    // if value is a string...
   if (typeof value === 'string') { 
      console.log( value.toUpperCase());
   }
   if(typeof value === 'number'){
      Math.random();
   }
//    if(typeof value === 'object'){
//     value // value: image | string[
//    }

  if(Array.isArray(value)){
    // value  value: string[]
    value.join('');
   }

   if(typeof value === 'object' && !Array.isArray(value)){
    //  value  value: image
    value.src; 
   }
}

logOutput('hi bro');
logOutput(1234);
logOutput(['hi','bro']);
logOutput({ src : 'image.jpg'})


// type Unions 
// interface image {
//     src: string;
// }
// function logOutput(value: string | number | string[] | image )
// {
   
// }

// logOutput('hi bro');
// logOutput(1234);
// logOutput(['hi','bro']);
// logOutput({ src : 'image.jpg'})

// logOutput(true); Argument of type 'boolean' is not assignable to parameter of type 'string | number | image | string[]'.


// Type Narrowing with Type Guards 

// interface image {
//     src: string;
// }
// function logOutput(value: string | number | string[] | image )
// {
//     // if value is a string...
//    if (typeof value === 'string') { 
//        value.toUpperCase();
//    }
// }

// logOutput('hi bro');
// logOutput(1234);
// logOutput(['hi','bro']);
// logOutput({ src : 'image.jpg'})


// Tricky cases with Type Guards

// interface image {
//     src: string;
// }
// function logOutput(value: string | number | string[] | image )
// {
//     // if value is a string...
//    if (typeof value === 'string') { 
//       console.log( value.toUpperCase());
//    }
//    if(typeof value === 'number'){
//       Math.random();
//    }
// //    if(typeof value === 'object'){
// //     value // value: image | string[
// //    }

//   if(Array.isArray(value)){
//     // value  value: string[]
//     value.join('');
//    }

//    if(typeof value === 'object' && !Array.isArray(value)){
//     //  value  value: image
//     value.src; 
//    }
// }

// logOutput('hi bro');
// logOutput(1234);
// logOutput(['hi','bro']);
// logOutput({ src : 'image.jpg'})

// Type Predicates 


interface image {
    src: string;
}
interface User {
    username : string
}
function logOutput(value: Image | User )
{
  if (typeof value === 'object'){
     value;
  }
}


logOutput({ src : 'image.jpg'});
logOutput({username : 'ladani prem'});



